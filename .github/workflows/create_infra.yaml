# - Takes env_name (used for both resource_group_name and name_prefix) and run_apply as inputs
# - Installs Terraform, logs into Azure, runs import, init, plan, and optionally apply
# - Each job logs into Azure to ensure env vars are available

run-name: Creating infrastructure - ${{ github.event.inputs.rg_name }}
name: "â˜ï¸ Create Infrastructure"

on:
  workflow_dispatch:
    inputs:
      rg_name:
        description: "Resource group name"
        required: true
        default: "eat"
        type: string

      name_prefix:
        description: "Prefix name (used for adding prefix to resources)"
        required: true
        default: "eat"
        type: string

      run_apply:
        description: "Run terraform apply?"
        required: false
        default: false
        type: boolean

concurrency:
  group: create-infra
  cancel-in-progress: true

jobs:
  import:
    name: "Terraform Import"
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: infra
    env:
      TF_VAR_resource_group_name: ${{ inputs.rg_name }}
      TF_VAR_name_prefix: ${{ inputs.name_prefix }}
      ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.8.5

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZ_CREDS }}

      - name: Terraform Init
        run: terraform init

      - name: Check Resource Group Existence
        id: check_rg
        run: |
          if az group show --name "${{ inputs.rg_name }}" --subscription "${{ secrets.AZURE_SUBSCRIPTION_ID }}"; then
            echo "rg_exists=true" >> $GITHUB_ENV
          else
            echo "rg_exists=false" >> $GITHUB_ENV
          fi

      - name: Terraform Import Resource Group
        if: env.rg_exists == 'true'
        run: |
          terraform import azurerm_resource_group.main "/subscriptions/${{ env.ARM_SUBSCRIPTION_ID }}/resourceGroups/${{ inputs.rg_name }}"
          echo "Terraform import succeeded."

      - name: List and Import All Resources from RG
        if: env.rg_exists == 'true'
        env:
          RG_NAME: ${{ github.event.inputs.rg_name }}
        run: |
          echo "Checking if resource group '$RG_NAME' exists..."

          # Check RG existence â€” will return non-zero if not found
          if ! az group show --name "$RG_NAME" &>/dev/null; then
            echo "âŒ Resource group '$RG_NAME' not found in the current subscription."
            exit 1
          fi

          echo "âœ… Resource group '$RG_NAME' exists."

          echo "Listing all resources in RG: $RG_NAME"

          # Get list of IDs
          az resource list \
            --resource-group "$RG_NAME" \
            --query "[].id" -o tsv |
          while read -r id; do
            # Derive Terraform-friendly name (replace invalid chars with underscores)
            echo "Deriving Terraform name for resource ID: $id"
            tf_name=$(basename "$id" | sed 's/[^a-zA-Z0-9_-]/_/g')
            echo "Terraform Name: $tf_name"

            # Derive Terraform type from Azure type
            # Example: Microsoft.Storage/storageAccounts => azurerm_storage_account
            echo "Deriving Terraform type from Azure Type for resource ID: $id"

            az_type=$(az resource show --ids "$id" --query "type" -o tsv | tr '[:upper:]' '[:lower:]')
            echo "Azure Type: $az_type"

            case "$az_type" in
              microsoft.compute/disks)
                tf_type="azurerm_managed_disk"
                tf_block="main"
                ;;
              microsoft.compute/virtualmachines)
                tf_type="azurerm_virtual_machine"
                tf_block="main"
                ;;
              microsoft.storage/storageaccounts)
                tf_type="azurerm_storage_account"
                tf_block="main"
                ;;
              microsoft.network/virtualnetworks)
                tf_type="azurerm_virtual_network"
                tf_block="main"
                ;;
              microsoft.network/networkinterfaces)
                tf_type="azurerm_network_interface"
                tf_block="main"
                ;;
              microsoft.network/publicipaddresses)
                tf_type="azurerm_public_ip"
                tf_block="main"
                ;;
              microsoft.sql/servers)
                tf_type="azurerm_mssql_server"
                tf_block="main"
                # ðŸ” Enumerate firewall rules for this server and import them too
                server_name="$tf_name"
                echo "Fetching firewall rules for SQL Server: $server_name"
                az sql server firewall-rule list \
                    --resource-group "$RG_NAME" \
                    --server "$server_name" \
                    --query "[].{name:name, id:id}" -o tsv |
                while read -r fr_name fr_id; do
                    echo "Importing firewall rule: $fr_name"
                    terraform import "azurerm_mssql_firewall_rule.allow_all" "$fr_id" \
                      || echo "âš ï¸ Import failed for firewall rule $fr_name"
                done
                ;;
              microsoft.sql/servers/databases)
                tf_type="azapi_resource"
                tf_block="sql_database"
                # Skip system database 'master'
                if [[ "${tf_name,,}" == "master" ]]; then
                    echo "â­ï¸ Skipping system database '$tf_name' â€” not managed in Terraform."
                    continue
                fi
                ;;
              microsoft.web/sites)
                if [[ "$tf_name" == *"ui"* ]]; then
                    idx_key="ui"
                else
                    idx_key="api"
                fi
                tf_type="azurerm_windows_web_app"
                tf_block="apps[\"${idx_key}\"]"
                ;;
              microsoft.web/serverfarms)
                tf_type="azurerm_service_plan"
                tf_block="main"
                ;;
              # microsoft.managedidentity/userassignedidentities)
              #   tf_type="azurerm_user_assigned_identity"
              #   tf_block="main"
              #   ;;
              # add more mappings here as needed
              *)
                tf_type=""
                tf_block=""
                ;;
            esac
            echo "Terraform Type: $tf_type"

            if [ -n "$tf_type" ]; then
              echo "Importing $tf_type.$tf_name from $id"
              terraform import "$tf_type.$tf_block" "$id" || echo "âš ï¸ Import failed for $id"
            else
              echo "âš ï¸ No Terraform type mapping for Azure type: $az_type"
            fi
          done

      - name: Create Empty tfstate if Resource Group Not Found
        if: env.rg_exists == 'false'
        run: |
          echo "Resource group not found. Creating empty tfstate file."
          echo '{"version":4,"resources":[]}' > terraform.tfstate

      - name: Upload Terraform State
        uses: actions/upload-artifact@v4
        with:
          name: tfstate-${{ inputs.rg_name }}
          path: infra/terraform.tfstate*

  plan:
    name: "Terraform Init & Plan"
    runs-on: ubuntu-latest
    needs: import
    defaults:
      run:
        working-directory: infra
    env:
      TF_VAR_resource_group_name: ${{ inputs.rg_name }}
      TF_VAR_name_prefix: ${{ inputs.name_prefix }}
      ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download Terraform State
        uses: actions/download-artifact@v4
        with:
          name: tfstate-${{ inputs.rg_name }}
          path: infra

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.8.5

      - name: Terraform Init
        run: terraform init

      - name: Terraform Plan
        run: |
          terraform plan -var "resource_group_name=${{ inputs.rg_name }}" -var "name_prefix=${{ inputs.name_prefix }}" | tee plan.txt
          exit ${PIPESTATUS[0]}

      - name: Upload Terraform Plan Output
        uses: actions/upload-artifact@v4
        with:
          name: plan-output
          path: infra/plan.txt

  plan-summary:
    name: "Terraform Plan Output"
    runs-on: ubuntu-latest
    needs: plan
    steps:
      - name: Download Terraform Plan Output
        uses: actions/download-artifact@v4
        with:
          name: plan-output
          path: infra

      - name: Add Terraform Plan to Job Summary
        run: |
          perl -pe 's/\e\[[0-9;]*[mK]//g' infra/plan.txt > infra/clean_plan.txt

          echo '' >> $GITHUB_STEP_SUMMARY

          awk '/^Plan: [0-9]+ to add, [0-9]+ to change, [0-9]+ to destroy\./ {print_flag=1}print_flag && !/\(known after apply\)/ {print}' infra/clean_plan.txt >> infra/summary.txt

          sed -E 's/^Plan: ([0-9]+) to add, ([0-9]+) to change, ([0-9]+) to destroy\./### ðŸ“‹ **Plan**: \1 to add ðŸ› ï¸, \2 to change ðŸ”„, \3 to destroy ðŸ’£/; s/^Changes to Outputs:/### ðŸ”§ Changes to Outputs:/; s/^  \+ ([a-zA-Z0-9_]+)\s+=\s+"(.*)"/- **\1**: `\2`/; s/^  \+ ([a-zA-Z0-9_]+)\s+=\s+\[$/- **\1**:/; s/^  \+ ([a-zA-Z0-9_]+)\s+=\s+\{/- **\1**:/; s/^    \+ ([a-zA-Z0-9_]+)\s+=\s+"(.*)"/  - **\1**: `\2`/; s/^    \+ ([a-zA-Z0-9_]+)\s+=\s+(.*)/  - **\1**: `\2`/; s/^      \+ ([a-zA-Z0-9_]+)\s+=\s+"(.*)"/  - **\1**: `\2`/; s/^      \+ ([a-zA-Z0-9_]+)\s+=\s+(.*)/  - **\1**: `\2`/; s/^    \+ "(.*)"/  - `\1`/; s/^      \+ \{//; s/^      \+ \}//; s/^\s*\{//; s/^\s*\}//; s/^\s*,\s*$//; s/^\s*\]$//' infra/summary.txt >> infra/formatted_summary.txt

          sed -E 's/^[[:space:]]*\+ ([a-zA-Z0-9_]+) = "(.*)"/  - **\1**: `\2`/; s/^[[:space:]]*\+ ([a-zA-Z0-9_]+) = ([^"].*)/  - **\1**: `\2`/; s/^[[:space:]]*\+ ?\{.*//; s/^[[:space:]]*\+ ?\}.*//; /^$/d' infra/formatted_summary.txt >> infra/cleaned_summary.txt

          sed '/^[â”€-]\{10,\}$/,/^$/d' infra/cleaned_summary.txt >> infra/final_summary.txt

          sed -i "s/- \*\*sql_database_details\*\*:/- **sql_database_name**: \\\`${{ inputs.name_prefix }}-db\\\`/" infra/final_summary.txt

          cat infra/final_summary.txt >> $GITHUB_STEP_SUMMARY

  apply:
    name: "Terraform Apply"
    runs-on: ubuntu-latest
    needs:
      - plan
      - plan-summary
    if: ${{ always() && github.event.inputs.run_apply == 'true' && needs.plan.result == 'success' && needs.plan-summary.result == 'success' }}
    defaults:
      run:
        working-directory: infra
    env:
      TF_VAR_resource_group_name: ${{ inputs.rg_name }}
      TF_VAR_name_prefix: ${{ inputs.name_prefix }}
      ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download Terraform State
        uses: actions/download-artifact@v4
        with:
          name: tfstate-${{ inputs.rg_name }}
          path: infra

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.8.5

      - name: Terraform Init
        run: terraform init

      - name: Terraform Plan
        run: terraform plan -var "resource_group_name=${{ inputs.rg_name }}" -var "name_prefix=${{ inputs.name_prefix }}" -out=tfplan

      - name: Terraform Apply
        run: terraform apply -auto-approve tfplan

      - name: Terraform Apply Summary
        run: |
          echo "### âœ… Terraform Apply was successful!" >> $GITHUB_STEP_SUMMARY
          echo "- **Resource Group**: '${{ inputs.rg_name }}'" >> $GITHUB_STEP_SUMMARY
          echo "- **Prefix Used**: '${{ inputs.name_prefix }}'" >> $GITHUB_STEP_SUMMARY

  update-workflow-options:
    name: "Update Workflow Options"
    needs:
      - apply
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Update Workflow Options
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
        run: |
          gh workflow run update_component_options.yaml \
            --ref master \
            --field new_components="${{ inputs.name_prefix }}-ui,${{ inputs.name_prefix }}-api,${{ inputs.name_prefix }}-db" \
            --field commit_to_master="true"
          # Wait for the workflow to complete before triggering builds
          sleep 30

  trigger-build-artifact:
    name: "Trigger Build Artifact Workflow"
    needs:
      - apply
      - update-workflow-options
    runs-on: ubuntu-latest
    strategy:
      matrix:
        build:
          - {
              component: "${{ inputs.name_prefix }}-ui",
              component_type: "angular",
            }
          - {
              component: "${{ inputs.name_prefix }}-api",
              component_type: ".net",
            }
          - {
              component: "${{ inputs.name_prefix }}-db",
              component_type: "sql-dacpac",
            }
    if: ${{ needs.apply.result == 'success' }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      - name: Trigger build_artifact workflow
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
        run: |
          gh workflow run build_artifact.yaml \
            --ref master \
            --field component="${{ matrix.build.component }}" \
            --field component_type="${{ matrix.build.component_type }}" \
            --field release_type="patch" \
            --field is_pre_release="false" \
            --field auto-deploy="true"
      - name: Get triggered build workflow run URL
        id: get_build_url
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
        run: |
          # Wait a few seconds to ensure the run is registered
          sleep 5
          RUN_ID=$(gh run list --workflow=build_artifact.yaml --branch ${{ github.ref_name }} --limit 1 --json databaseId --jq '.[0].databaseId')
          BUILD_RUN_URL="https://github.com/${{ github.repository }}/actions/runs/$RUN_ID"
          echo "Build workflow run URL: $BUILD_RUN_URL"
          echo "BUILD_RUN_URL=$BUILD_RUN_URL" >> $GITHUB_ENV
      - name: Trigger Summary
        run: |
          echo "### ðŸš€ Triggered Build Artifact Workflow" >> $GITHUB_STEP_SUMMARY
          echo "- **Component:** ${{ matrix.build.component }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Type:** ${{ matrix.build.component_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- [View Build Workflow Run]($BUILD_RUN_URL)" >> $GITHUB_STEP_SUMMARY

  cleanup:
    runs-on: ubuntu-latest
    needs:
      - import
      - plan
      - plan-summary
      - apply
      - trigger-build-artifact
    if: always() # âœ… runs even if any job fails
    steps:
      - name: Delete artifacts
        uses: geekyeggo/delete-artifact@v5
        with:
          name: "*"
          failOnError: false
